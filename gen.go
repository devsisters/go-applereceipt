//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

var sectionPattern = regexp.MustCompile(`<h2 class="jump">(.+?)</h2>`)
var fieldDefPattern = regexp.MustCompile(`<h3 class="jump">(.+?)</h3>\s*<p>(.+?)</p>\s*<p>\s*<strong>\s*ASN.1 Field Type\s*</strong>\s*(.+?)</p>\s*<p>\s*<strong>\s*ASN.1 Field Value\s*</strong>\s*(.+?)</p>`)
var tpl = template.Must(template.New("").Funcs(map[string]any{
	"asn1GoType":  asn1GoType,
	"asn1Decoder": asn1Decoder,
}).Parse(`// Code generated by gen.go. DO NOT EDIT.
package applereceipt

import (
	"encoding/asn1"
	"time"
)

var (
	_ asn1.RawValue
	_ time.Time
)

{{ range . }}
type {{ .Name }} struct {
	{{- range .Fields }}
	// {{ .Description }}
	{{- if eq .Type 17 }}
	{{ .Name }}s []{{ .Value | asn1GoType }}
	{{- else }}
	{{ .Name }} {{ .Value | asn1GoType }}
	{{- end }}
	{{- end }}

	// Undocumented attributes
	Remaining []ReceiptAttribute
}

func new{{ .Name }}(attrs []ReceiptAttribute) ({{ .Name }}, error) {
	var r {{ .Name }}
	for _, attr := range attrs {
		var err error
		switch attr.Type {
		{{- range .Fields }}
		case {{ .Type }}:
			{{ printf "r.%s" .Name | asn1Decoder .Value }}
		{{- end }}
		default:
			r.Remaining = append(r.Remaining, attr)
		}
		if err != nil {
			return r, err
		}
	}
	return r, nil
}
{{ end }}
`))

type TypeDef struct {
	Name   string
	Fields []FieldDef
}

func main() {
	resp, err := http.Get("https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	content, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	var types []TypeDef
	sections := sectionPattern.FindAllSubmatchIndex(content, -1)
	end := len(content)
	for i := len(sections) - 1; i >= 0; i-- {
		section := sections[i]
		sectionName := string(content[section[2]:section[3]])
		fields := parseFields(content[section[3]:end])
		types = append(types, TypeDef{
			Name:   illegalNameChars.ReplaceAllString(strings.TrimSuffix(sectionName, " Fields"), ""),
			Fields: fields,
		})
		end = section[0]
	}
	buf := &bytes.Buffer{}
	if err := tpl.Execute(buf, types); err != nil {
		panic(err)
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	if err := os.WriteFile("receipts.go", src, 0644); err != nil {
		panic(err)
	}
}

type FieldDef struct {
	Name        string
	Description string
	Type        int
	Value       string
}

var illegalNameChars = regexp.MustCompile(`[^a-zA-Z0-9]`)

func parseFields(content []byte) []FieldDef {
	defs := fieldDefPattern.FindAllSubmatchIndex(content, -1)
	fields := make([]FieldDef, 0, len(defs))
	for _, def := range defs {
		fieldName := string(content[def[2]:def[3]])
		fieldDesc := string(content[def[4]:def[5]])
		fieldType := string(content[def[6]:def[7]])
		fieldValue := string(content[def[8]:def[9]])
		if fieldType == "(none)" || fieldValue == "(none)" {
			continue
		}
		fieldName = illegalNameChars.ReplaceAllString(fieldName, "")
		fieldTypeNum, err := strconv.Atoi(fieldType)
		if err != nil {
			fmt.Printf("Ignoring field %q: error parsing field type %q: %v", fieldName, fieldType, err)
		}
		fields = append(fields, FieldDef{
			Name:        fieldName,
			Description: fieldDesc,
			Type:        fieldTypeNum,
			Value:       fieldValue,
		})
	}
	return fields
}

func asn1GoType(asn1ValueType string) string {
	switch strings.ToLower(asn1ValueType) {
	case "utf8string":
		return "string"
	case "a series of bytes", "20-byte sha-1 digest":
		return "[]byte"
	case "integer":
		return "int"
	case "ia5string, interpreted as an rfc 3339 date":
		return "time.Time"
	case "set of in-app purchase receipt attributes":
		return "InAppPurchaseReceipt"
	default:
		return ""
	}
}

func asn1Decoder(asn1ValueType, dest string) string {
	switch strings.ToLower(asn1ValueType) {
	case "utf8string":
		return "_, err = asn1.UnmarshalWithParams(attr.Value, &" + dest + ", \"utf8\")"
	case "a series of bytes", "20-byte sha-1 digest":
		return dest + " = attr.Value"
	case "integer":
		return "_, err = asn1.Unmarshal(attr.Value, &" + dest + ")"
	case "ia5string, interpreted as an rfc 3339 date":
		return `var s string
			if _, err = asn1.Unmarshal(attr.Value, &s); err == nil && s != "" {
				` + dest + `, err = time.Parse(time.RFC3339, s)
			}`
	case "set of in-app purchase receipt attributes":
		return `var attrs []ReceiptAttribute
			if _, err = asn1.UnmarshalWithParams(attr.Value, &attrs, "set"); err == nil {
				var iap InAppPurchaseReceipt
				iap, err = newInAppPurchaseReceipt(attrs)
				if err == nil {
					` + dest + `s = append(` + dest + `s, iap)
				}
			}`
	default:
		return ""
	}
}
